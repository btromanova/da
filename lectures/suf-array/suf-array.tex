%\documentclass[11pt,a4paper]{article}
%\usepackage{fullpage}
%\usepackage{beamerarticle}
%\documentclass[handout,xcolor=pdftex,dvipsnames,table]{beamer}
\documentclass[hyperref={unicode=true}]{beamer}

%\usepackage{pgfpages} 
%\pgfpagesuselayout{resize}[a4paper,border shrink=5mm,landscape] 

\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{../clrscode3e} 
%\usepackage[all]{xy}
\usepackage{colortbl}
%\usepackage{xcolor}
\usepackage{pstricks, pst-tree, pst-node}
\usepackage{epsfig}
\usepackage{multicol}
%\usepackage{listings}

\definecolor{orange}{cmyk}{0,0.52,1,0}

%\usepackage{beamerthemesplit}

\AtBeginSection[]
{
  \begin{frame}<beamer>{Раздел}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}


\newtheorem{rtheorem}{Теорема} 
\newtheorem{rconsequence}{Следствие} 
%default}
%themesplit}

\title{Суффиксные массивы}
\subtitle{Дискретный анализ 2012/13}
\author{Андрей Калинин, Татьяна Романова}
\date{10 декабря 2012\,г. }
\usetheme{default}
%\usefonttheme{serif}
\usefonttheme[onlymath]{serif}
%\usefonttheme{professionalfonts}
%\usetheme{default} 


\begin{document}

\frame{\titlepage}

%\section[Содержание]{}
\frame{\tableofcontents}

%\section{Литература}
\frame
{
  \frametitle{Литература}

  \begin{itemize}
  \item Дэн Гасфилд, <<Строки деревья и последовательности в алгоритмах:
    Информатика и вычислительная биология>>, 2003. Глава 7,
    <<Первые приложения суффиксных деревьев>>, стр. 158--213.  
  \item Построение суффиксных массивов за $O(n\log n)$ http://e-maxx.ru/algo/suffix\_array
  \end{itemize}
}


\section{Суффиксные массивы}

\subsection{Определение}
\frame{
  \frametitle{Мотивация}

  \begin{itemize}
  \item Полное суффиксное дерево занимает слишком много памяти. 
  \item Суффиксное дерево зависит от размера алфавита. 
  \item При построении: либо память $\Theta(m|\Sigma|)$, либо время
    $O(\min\{m\log m, m \log |\Sigma| \})$.
  \item Поиск образца выполняется за время $O(n)$ при размере памяти
    $\Theta(m|\Sigma|)$. Иначе, за $O(n \min \{ \log m, \log |\Sigma|\})$.
  \item Можно ли придумать иную структуру данных, которая бы позволяла
    бы искать 
    некоторые задачи, решаемые суффиксным деревом, с аналогичными
    временными характеристиками?
  \end{itemize}
}

\frame{
  \frametitle{Суффиксный массив}
  \begin{block}{Определение}
    Суффиксным массивом для $m$-символьной строки $Pos$ называется
    массив целых чисел от 1 до $m$, определяющий лексикографический
    порядок $m$ суффиксов строки $T$.
  \end{block}
  \begin{itemize}
  \item Т.е., суффикс, начинающийся в $Pos(1)$ строки $T$ лексикографически
    самый маленький, а суффикс $Pos(i)$ меньше $Pos(i+1)$.
  \item Терминальный символ счиатется лексикографически меньше любого
    другого символа исходного алфавита. 
  \item При добавлении ещё $2m$ значений суффиксный массив можно
    использовать  для поиска всех вхождений в $T$ образца $P$ за
    $O(n+\log m)$ операций вне зависимости от размера алфавита.  
  \end{itemize} }
\frame{
  \frametitle{Пример суффиксного массива}
  Для строки $mississipi$ масив $Pos = (11, 8, 5, 2, 1,
  10,9,7,4,6,3)$:\\
~\\
    \begin{tabular}{rl}
      11 & i \\
      8 & ippi \\
      5 & issippi \\
      2 & ississippi \\
      1 & mississippi \\
      10 & pi \\
      9 & ppi \\
      7 & sippi \\
      4 & sisippi \\
      6 & ssippi \\
      3 & ssissippi
    \end{tabular}
}

\subsection{Построение с использованием деревьев}

\frame{
  \frametitle{Построение суффиксного массива}
  \begin{itemize}
  \item Для текста $T$ построить суффиксное дерево $\mathbb{T}$. 
  \item Обойти дерево $\mathbb{T}$ в глубину таким образом, что
    первыми проходятся дуги, чьи метки меньше остальных в
    лексикографическом смысле. 
  \item Если дуги хранятся в порядке возрастаний первых символов
    меток, то такой обход будет натуральным 
  \item Суффиксный массив --- просто список посещений листьев при
    таком обходе. 
  \item Тем самым, суффиксный массив строится за время $O(m)$.
  \end{itemize}
}

\section{Использование суффиксных массивов}

\subsection{Поиск образцов}
\frame{
  \frametitle{Поиск образца}
  \begin{itemize}
  \item Если образец $T$ входит в $T$, то все суффиксы, начинающиеся с
    $P$ в массиве $Pos$ будут располагаться рядом. 
  \item Нужно выполнить двоичный поиск $P$ в массиве $Pos$: найти
    наименьший индекс $i$, такой что $Pos(i-1)$ не начинается с $P$ и
    наибольший $i'$, что $Pos(i'+1)$  не начинается с $P$. Тогда есть
    вхождение образца в позициях от $Pos(i)$ до $Pos(i')$.
  \item Пессимистичная оценка времени работы $O(n \log m)$,
    достигается при наличии большого количества длинных префиксов $P$.
  \item Можно улучшить до $O(n+\log m)$.
  \end{itemize}
}

\frame{
  \frametitle{Простое ускорение}

  \begin{itemize}
  \item $L$ и $R$ --- текущие границы интервала поиска. В начале $L=1$
    и $R=m$.
  \item Запоминается длина префиксов $Pos(L)$ и $Pos(R)$, совпадающих
    с префиксом $P$: $l$, $r$.
  \item $mlr = \min(l,r)$.
  \item При очередном сравнеии в позиции $M=\lfloor (R+L)/2 \rfloor$
    можно начинать обрабатывать символы не с первой позиции, а с
    $mlr(l,r)+1$.
  \item На практике достигается $O(n+\log m)$, однако в худшем случае
    остается $O(n\log m)$.
  \end{itemize}
}

\subsection{Ускорение с использованием Lcp}
\frame{
  \frametitle{Значения $Lcp(i,j)$}

  \begin{itemize}
  \item Проверка символа в $P$ избыточная, если этот символ был
    проверен ранее. 
  \item Цель: уменьшить количество избыточных проверок до не более
    одной на каждую итерацию бинарного поиска. 
  \item $mlr$ не подходит, т.к при при $l \neq r$ все символы до
    $\max(l,r)>1$ уже проверялись. 
  \item $Lcp(i,j)$ --- длина наибольшего общего префикса суффиксов
    $Pos(i)$ и $Pos(j)$.
  \item Для $T=mississippi$ $Pos(3)$ --- $issippi$, а $Pos(4)$ ---
    $ississippi$, т.е. $Lcp(3,4)=4$.
  \end{itemize}
}

\frame{
  \frametitle{Использование $Lcp$}

  \begin{itemize}
  \item $M \gets \lfloor (R+L)/2 \rfloor$.
  \item $l = r$, тогда сравнение $P$ с $Pos(M)$ начинается с позиции
    $mlr(l,r)+1=l+1=r+1$.
  \item $l \neq r$, предположим что $l>r$:
    \begin{enumerate}
      \item $Lcp(L,M)>l$: $P$ совпадает с $Pos(M)$ на $l$ символов, и
        $l+1$-й символ у $Pos(L)$ и $Pos(M)$ совпадает, т.е. $L \gets
        M$ без проверок символов. 
      \item $Lcp(L,M)<l$: $P$ совпадает с $Pos(M)$ на $Lcp(L,M)$
        символов, а $Lcp(L,M)+1$-й символ у $Pos(L)$ и $P$ совпадает,
        т.е.  $R \gets M$, $r \gets Lcp(L,M)$.
      \item $Lcp(L,M)=l$: $P$ совпадает с $Pos(M)$ на $l$ символов,
        нужно явно сравнивать символы с $l+1$-го и решить, что делать
        по правилам бинарного поиска (запомнив $l$ и $r$).
    \end{enumerate}
  \end{itemize}
}

\frame{
  \frametitle{$Lcp(L,M)>l$}
\begin{tabular}{rll}
$P$ & \texttt{abcdemn} \\
$L$ & \texttt{abcdefg} & $l=5$\\
$M$ & \texttt{abcdefg} & $Lcp(L,M)=6$\\
$R$ & \texttt{abcdxyz} & $r=4$\\
\end{tabular}
}

\frame{
  \frametitle{Эффективность использования $Lcp$}
  \begin{rtheorem}
    При использовании значений $Lcp$ поисковый алгоритм делает не
    более $O(n+\log m)$ сравнений и работает за такое же время. 
  \end{rtheorem}
  \begin{proof}
    \begin{itemize}
  \item  $l$ и $r$ не уменьшаются. 
  \item В сучаях $l=r$ или $Lcp(L,M)=l>r$ алгоритм начинает проверку с
    $\max(l,r)$ символа и либо увеличивает $l$ или $r$, или
    заканчивает работу. 
  \item Тем самым, не более одного избыточного сравнения на итерацию,
    т.е. количество сравнений $n+\log m$.
  \end{itemize}
  \end{proof}
}

\frame{
  \frametitle{Вычисление $Lcp$}
  \pstree[levelsep=30pt]{\Tr{1,8}}{
    \pstree{\Tr{1,4}}{
        \pstree{\Tr{1,2}}{
          \pstree{\Tr{1,1}}{}
          \pstree{\Tr{1,2}}{}
        }
        \pstree{\Tr{2,4}}{
          \pstree{\Tr{2,3}}{}
          \pstree{\Tr{3,4}}{}
        }
      }
    \pstree{\Tr{4,8}}{
        \pstree{\Tr{4,6}}{
          \pstree{\Tr{4,5}}{}
          \pstree{\Tr{5,6}}{}
        }
        \pstree{\Tr{6,8}}{
          \pstree{\Tr{6,7}}{}
          \pstree{\Tr{7,8}}{}
        }
      }
  } \\
  Здесь каждая внутренняя вершина $(i,j)$ имеет двух детей, $(i,
  \lfloor (i+j)/2 \rfloor)$ и  $(\lfloor (i+j)/2 \rfloor, j)$. Т.е.,
  при работе двоичного поиска понадобятся только $2m-1$ значений $Lcp(i,j)$.
}

\frame{
  \frametitle{Вычисление $Lcp$}

  \begin{itemize}
  \item При обходе дерева $\mathbb{T}$ во время построения суффиксного
    массива $Pos$ ближайшая к корню вершина, посещённая при переходе
    от $Pos(i)$ к $Pos(i+1)$ определяет значение $Lcp(i,i+1)$ равным
    её строковой глубине. 
  \item $Lcp(i,j) =  \displaystyle\min_{i\leq k <j}\{ Lcp(k, k+1)\} $
  \item Отсюда, можно вычислить при построении суффиксного массива
    значения $Lcp(i,i+1)$, а потом достроить за линейное время
    оставшиеся значения, которые могут понадобиться при бинарном
    поиске. 
  \item Тем самым: с использованием суффиксных массивов
    предварительная обработка занимает время $O(m)$, а 
    время работы составляет $O(n+\log m)$.
  \end{itemize}
}

\section {Построение без использования деревьев}

\frame {
  \frametitle{Общее описание}
   \begin{itemize}
     \item Вместо суффиксов будем сортировать циклические сдвиги строки.
     \item Для получения этим алгоритмом суффиксного массива достаточно добавить в конец
           строки символ с наименьшим кодом (например, нулевой символ в Си).
     \item Алгоритм будет состоять из $k=0 \dots \lceil \log n \rceil $ фаз, на $k$-й фазе сортируются 
           циклические подстроки длины $2^k$.
     \item На последней фазе получим остортированный массив циклических сдвигов.
  \end{itemize}
}

\frame {
  \frametitle{Вспомогательные массивы}
    \begin{itemize}
      \item Массив $p$ на $k$-й итерации будет содержать индексы отстортированных циклических строк размера $2^k$.
      \item В массиве $c$ на $i$-й позиции будет храниться номер класса эквивалентности, которому принадлежит строка,
            начинающаяся с $i$ размером $2^k$.
      \item Меньшая строка получает меньший класс эквивалентности. У одинаковых строк классы совпадают. Классы нумеруются с нуля.
    \end{itemize}
    
    Пример:\\
     Строка $\texttt{aaba}$ \\
     \begin{tabular}{c|c|c|l}
     $k$ & $p$ & $c$ & сортируемые подстроки  \\
     \hline
     0 & (0, 1, 3, 2) & (0, 0, 1, 0) & (a, a, b, a) \\
     1 & (0, 3, 1, 2) & (0, 1, 2, 0) & (aa, ab, ba, aa) \\
     2 & (3, 0, 1, 2) & (1, 2, 3, 0) & (aaba, abaa, baaa, aaab)\\
     \end{tabular} \\
}

\frame {
  \frametitle{Нулевой шаг}
    \begin{itemize}
      \item При $k=0$ сортируются отдельные символы.
      \item Это можно сделать сортировкой подсчетом, на нулевом месте массива $p$ окажется индекс наименьшего символа.
      \item С помощью прохода по $p$ и сравнения заполним массив $c$ (если $s[p[i]] != s[p[i-1]]$ увеличиваем номер класса эквивалентности).
      \item Время работы на нулевом шаге~--- $O(n)$.
    \end{itemize}

     Если мы научимся за $O(n)$ переходить от $k$-го шага к $k+1$-му, то так как фаз всего $\log n$, общее время работы алгоритма будет $O(n \log n)$.
}

\frame {
   \frametitle{От $k$-го к $k+1$-му}
    \begin{itemize}
       \item Циклическая строка длины $2^k$ состоит из двух циклических подстрок длины $2^{k-1}$, которые мы сравнивали на предыдущем шаге.
       \item Для строки, начинающейся в позиции $i$, возьмем данные из массива $c$, построенного на предыдущем шаге: $(c[i], c[i + 2^{k-1}])$.
       \item Сортировка по этим парам даст нам новый массив $p$.
       \item Новый $c$ построим, пройдя по $p$ и сравнив две пары значений из предыдущего массива $c$.
       \item Получившееся время работы: $O(n \log^2 n)$~--- $\log n$ шагов с сортировкой на каждом шаге. 
    \end{itemize}
}

\frame {
   \frametitle{Ускорение}
    \begin{itemize}
      \item Для сортировки пар используем поразрядную сортировку: сначала по вторым элементам пары, затем по первым.
      \item Сортировка по вторым элементам уже содержится в предыдущем массиве $p$. Поэтому просто вычисляем индекс
            соответствующего первого элемента ($p[i] - 2^{k-1}$) и сохраняем его на $i$-й позиции. (Придется завести дополнительный массив).
      \item Для упорядочения по первым элементам используем сортировку подсчетом, как на нулевом шаге.
      \item Массив $c$ получаем аналогично предыдущим вариантам алгоритма.
      \item Время работы: $O(n \log n)$, код алгоритма: http://e-maxx.ru/algo/suffix\_array.
    \end{itemize} 
} 

\frame {
  \frametitle {Пример}
   Строка:  $s=\texttt{aabacaac}$\\
   \begin{itemize}
     \item $n = 8 \Rightarrow k = 0 \dots 3$ 
     \item $k = 0$
     \item Сортировка подсчетом:
        \begin{itemize}
           \item $cnt = (5, 1, 2)$~--- считаем, сколько раз встречается каждая буква
           \item $cnt = (5, 6, 8)$~--- $cnt[i] += cnt[i - 1]$ 
           \item $p = (0, 1, 3, 5, 6, 2, 4, 7)$~--- заполняем массив $p$ индексами строки $s$, проходя по ней с конца.
         \end{itemize}
     \item$c = (0, 0, 1, 0, 2, 0, 0, 2)$~--- заполянем $c[p[i]]$, сравнивая $s[p[i]]$ и $s[p[i-1]]$.
     \end{itemize}
}

\frame {
  \frametitle{Пример}
   \begin{itemize}
    \item $k = 1$ (рассматриваем строки длиной 2)
    \item $pn = (7, 0, 2, 4, 5, 1, 3, 6)$~--- заполняем вспомогательный массив: $pn[i] = p[i] - 1$.
    \item  Получили массив, отсортированный по вторым буквам строк длиной 2.
    \item Сортировка подсчетом:
      \begin{itemize}
         \item $cnt = (5, 1, 2)$, $cnt = (5, 6, 8)$~--- подсчитываем, используя предыдущий $c$.
         \item $p = (. . . . 6 . . .) \to (. . . 3 6 . . .) \to (. . 1 3 6 . . .) \to (. 5 1 3 6 . . .) \to (. 5 1 3 6 . . 4) \to (. 5 1 3 6 2 . 4) \to (0 5 1 3 6 2 . 4) \to (0 5 1 3 6 2 7 4)$. 
        \end{itemize}
     \item $c = (0 . . . . . . .) \to (0 . . . . 0 . .) \to (0 1 . . . 0 . .) \to (0 1 . 2 . 0 . .) \to (0 1 . 2 . 0 2 .) \to (0 1 3 2 . 0 2 .) \to (0 1 3 2 . 0 2 4) \to (0 1 3 2 4 0 2 4)$
     \end{itemize}
}

\frame {
  \frametitle{Пример}
   \begin{itemize}
    \item $k = 2$ (рассматриваем строки длиной 4)
    \item $pn = (6, 3, 7, 1, 4, 0, 5, 2)$~--- заполняем вспомогательный массив: $pn[i] = p[i] - 2$.
    \item  Получили массив, отсортированный по вторым двум буквам строк длиной 4.
    \item Сортировка подсчетом:
      \begin{itemize}
         \item $cnt = (2, 1, 2, 1, 2)$, $cnt = (2, 3, 5, 6, 7)$~--- подсчитываем, используя предыдущий $c$.
         \item $p = (. . . . . 2 . .) \to (. 5 . . . 2 . .) \to (0 5 . . . 2 . .) \longrightarrow (0 5 1 6 3 2 7 4)$. Заполняется проходом по $pn$ из конца в начало: $p[--cnt[c[pn[i]]]] = pn[i]$. 
         \end{itemize}
     \item $c = (0 2 4 3 6 1 3 5)$
     \end{itemize}
}

\frame {
  \frametitle{Пример}
   \begin{itemize}
    \item $k = 3$ (рассматриваем строки длиной 8)
    \item $pn = (4, 1, 5, 2, 7, 6, 3, 0)$~--- заполняем вспомогательный массив: $pn[i] = p[i] - 4$.
    \item Сортировка подсчетом:
      \begin{itemize}
         \item $cnt = (1, 1, 1, 2, 1, 1, 1)$, $cnt = (1, 2, 3, 5, 6, 7, 8)$~--- подсчитываем, используя предыдущий $c$.
         \item $p = (0 . . . . . . .) \to (0 . . . 3 . . .) \to (0 . . 6 3 . . .) \longrightarrow (0 5 1 6 3 2 7 4)$. 
         \end{itemize}
     \end{itemize}
     Результирующий суффиксный массив: $p = (0, 5, 1, 6, 3, 2, 7, 4)$.
}


\end{document}
