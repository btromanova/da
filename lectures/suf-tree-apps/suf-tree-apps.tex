%\documentclass[11pt,a4paper]{article}
%\usepackage{fullpage}
%\usepackage{beamerarticle}
%\documentclass[handout,xcolor=pdftex,dvipsnames,table]{beamer}
\documentclass[hyperref={unicode=true}]{beamer}

%\usepackage{pgfpages} 
%\pgfpagesuselayout{resize}[a4paper,border shrink=5mm,landscape] 

\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{../clrscode3e} 
%\usepackage[all]{xy}
\usepackage{colortbl}
%\usepackage{xcolor}
\usepackage{pstricks, pst-tree, pst-node}
\usepackage{epsfig}
\usepackage{multicol}
%\usepackage{listings}

\definecolor{orange}{cmyk}{0,0.52,1,0}

%\usepackage{beamerthemesplit}

\AtBeginSubsection[]
{
  \begin{frame}<beamer>{Раздел}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}


\newtheorem{rtheorem}{Теорема} 
\newtheorem{rconsequence}{Следствие} 
%default}
%themesplit}

\title{Приложения суффиксных деревьев}
\subtitle{Дискретный анализ 2012/13}
\author{Андрей Калинин, Татьяна Романова}
\date{26 ноября 2012\,г. }
\usetheme{default}
%\usefonttheme{serif}
\usefonttheme[onlymath]{serif}
%\usefonttheme{professionalfonts}
%\usetheme{default} 


\begin{document}

\frame{\titlepage}

%\section[Содержание]{}
\frame{\tableofcontents}

%\section{Литература}
\frame
{
  \frametitle{Литература}

  \begin{itemize}
  \item Дэн Гасфилд, <<Строки деревья и последовательности в алгоритмах:
    Информатика и вычислительная биология>>, 2003. Главa 7,
    <<Первые приложения суффиксных деревьев>>, стр. 158--213.  
  \end{itemize}
}


\section{Суффиксные деревья}

\subsection{Некоторые подробности}

\frame{
  \frametitle{Суффиксное дерево для набора строк}

  \begin{itemize}
     \item Можно обобщить определение суффиксного дерева для набора строк $\{S_1, S_2, \dots, S_z\}$: такое дерево содержит в себе все суффиксы каждой из строк набора.
     \item Добавить к каждой строке уникальный терминальный символ, после чего сконкатенировать все строки и построить суффиксное дерево для результата.
     \item Можно и без конкатенации: последовательно добавляя строки в дерево и продолжая алгоритм Укконена.
  \end{itemize}
}

\frame {
   \frametitle{Практическая реализация}
     \begin{itemize}
       \item Для очень длинных строк и больших алфавитов свойства алгоритма и 
             использования деревьев ухудшаются.
       \item Как хранить дуги? Варианты: массив размера $|\Sigma|$, линейный список,
             сбалансированные деревья, хеш.
       \item В любом случае, время работы зависит от размера алфавита, честная оценка времени построения дерева
             не линейная: $O(m\log|\Sigma|)$.
       \item Возможен иной подход к хранению суффиксных деревьев: суффиксные массивы.
     \end{itemize}
}

\section{Применения суффиксных деревьев}

\subsection{Поиск подстрок}

\frame {
  \frametitle{Поиск подстроки в тексте}
    \begin{itemize}
       \item Поистоить суффиксное дерево для текста.
       \item Пройти по нему от корня по пути с меткой $P$.
       \item Если такой путь существует, то все листы в поддереве~--- вхождения в текст.
       \item Можно предложить способ с предварительной обработкой образца (позже).
    \end{itemize}
}

\frame {
  \frametitle{Множественный поиск}
    \begin{itemize}
      \item Построить суффиксное дерево.
      \item Для каждого образца выполнить поиск.
      \item Время работы $O(m+n+k)$, где $k$~--- число вхождения образцов.
      \item Оценка аналогична алгоритму Ахо-Корасика, но более простое обобщение.
    \end{itemize}
}

\frame {
   \frametitle{Подстрока для базы образцов}
      \begin{itemize}
         \item Есть фиксированный набор строк (база данных). Нужно для строки $S$ найти в базе данных все строки, содержащие $S$ как подстроку.
         \item Для всех строк из базы данных строится обобщенное суффиксное дерево.
         \item В этом деереве ищется путь с меткой $S$: листья в поддереве этого пути соответствуют всем вхождениям
               строки $S$ в образцы из базы данных.
         \item Время подготовки $O(m)$, время поиска $O(n+k)$.
         \item Ни один из рассмотренных до сих пор алгоритмов не обладает такими свойствами.
      \end{itemize}
}

\frame {
   \frametitle{Линеаризация циклической строки}
     \begin{itemize}
       \item Циклическая строка $S$~--- за $S(n)$ следует $S(1)$.
       \item Существует $n$ вариантов разрезов циклической строки.
       \item Необходимо определить место разреза $S$ таким образом, чтобы полученная линейная строка была лексически
             наименьшей среди всех $n$ возможных строк, созданных разрезанием $S$.
       \item Например, для $baac$ требуется найти разрез $aacb$.
     \end{itemize}
}

\frame {
  \frametitle{Решение с помощью суффиксных деревьев}
    \begin{itemize}
      \item Разрежем строку $S$ в произвольном месте, получив линейную строку $L$.
      \item Удвоим $L$, получив $LL$.
      \item Построим суффиксное дерево $\mathbb{T}$ для $LL$.
      \item Проходим $\mathbb{T}$ таким образом, чтобы в каждом узле двигаться по дуге с наименьшим первым
            символом.
      \item Обход заканчиваем при достижнии строковой глубины $n$.
      \item Все листья найденного поддерева могуть быть использованы для искомого разреза.
    \end{itemize}
}

\subsection{Общие подстроки}
\frame {
   \frametitle{Наибольшая общая подстрока двух строк}
     \begin{itemize}
       \item Даны две строки $S_1$ и $S_2$, необходимо найти наибольшую их общую подстроку.
       \item Построим обобщенное суффиксное дерево для $\{S_1, S_2\}$.
       \item Пометим каждую внутреннюю вершину числом 1, если в ее поддереве существует лист $S_1$ и 2~--- если
             есть лист $S_2$.
       \item Такую разметку дерева можно сделать за один его обход.
       \item  Путевая метка вершины, помеченной одновременно 1 и 2~--- общая подстрока.
       \item Вершина, помеченная 1 и 2 с максимальной строковой глубиной соответствует наибольшей общей подстроке.
     \end{itemize}
}

\frame {
   \frametitle{Общие подстроки более чем двух строк}
     \begin{itemize}
        \item Есть $K$ строк, Общей длиной $n$. Для $2\leqslant k \leqslant K$ определим $l(k)$ 
              как длину самой длинной подстроки, общей для $\geqslant k$ строк.
        \item Нужно рассчитать $C(v)$~--- число различных строковых идентификаторов в листьях из поддерева вершины $v$.
        \item Можно держать битовый вектор длиной $K$ у каждой вершины: $i$-и бит соответствует наличию суффикса из $i$-й строки в поддереве.
        \item При обходе дерева такой вектор для каждой вершины получается битовым сложение векторов прямых потомков.
        \item Время работы: $O(Kn)$.
     \end{itemize}
}

\subsection{Статистика совпадений}

\frame {
  \frametitle{Определение}
  \textbf{Статистика совпадений}~--- это массив $ms$, размером с текст, в котором каждый элемент $msr(i)$ 
          является длиной наибольшей подстроки $T$, начинающейся с позиции $i$, 
          совпадающей с какой-то подстрокой $P$. Если есть вхождение $P$ в позиции $i$, то $msr(i) = |P|$.

  \vspace{1cm}

  \textbf{Пример}


  Образец: $\mathtt{wyabcwzqabcdw}$


  \begin{tabular}{ccccccccccc}
     $T$    & a & b& c& x& a& b& c& d& e& x \\
     $ms_i$ & 3& 2& 1& 0& 4& 3& 2& 1& 0& 0 \\
  \end{tabular} \\
  
  Значения $ms(i)$ можно найти, последовательно прикладывая суффиксное дерево для $P$
  к каждой позиции $T$ (но это не линейно!)
}

\frame {
  \frametitle{Вычисление статистики совпадений}
  \begin{itemize}
     \item Строится суффиксное дерево $\mathbb{T}$ для образца $P$,
           суффиксные связи сохраняются.
     \item Явно вычисляется $ms(1)$: поиском пути максимальной длины для
           $T[1..m]$. Находим точку $b$ внутри $\mathbb{T}$, в которой заканчивается
           строка $T[1..ms(1)]$.
     \item $ms(i+1)$ строится по $ms(i)$ так:
       \begin{itemize}
          \item Если $b$ находится во внутренней вершине $v$, то проходим в $s(v)$.
          \item Если  $b$ не внутренняя вершина, то поднимаемся до ближайшей вершины $v$, откуда переходим в $s(v)$
                и дальше спускаемся <<прыжком по счетчику>>.
          \item Таким образом, находим, где кончается подстрока, соответсвтующая $b$ без первого символа. Оттуда
                продолжаем прямое стравнение с символом $T(i + ms(i))$ и далее.
       \end{itemize}
  \end{itemize}
}

\frame {
   \frametitle{Корректность и линейность}
     \textbf{Корректен}, так как имитирует прямой метод нахождения статистики совпадений.
     
     \vspace{1cm}
   
     \textbf{Линейность} обосновывается аналогично линейности алгоритма Укконена: отслеживается вершинная глубина
            и ее изменение при вычислении $ms(i+1)$ по $ms(i)$. 
}

\frame {
   \frametitle{Небольшое обобщение}
      Для позиции $i$ в $T$ число $p(i)$ указывает начальную позицию в $P$, такую, что 
      $P[p(i)..p(i) + ms(i) - 1] = T[i..i + ms(i) - 1]$.

      \vspace{1cm}

      Расчет $p(i)$:
      \begin{enumerate}
        \item Каждая вершина дерева помечается номером какого-нибудь листа из своего поддерева, $p'(v)$.
        \item Если поиск значения $ms(i)$ останавливается в вершине $v$, то $p(i) \leftarrow p'(v)$.
        \item Если же поиск останавливается на дуге $<v, u>$, то $p(i) \leftarrow p'(u)$.
      \end{enumerate}
}

\frame {
   \frametitle{Наибольшая общая подстрока двух строк}
     \begin{enumerate}
        \item Построкить суффиксное дерево для меньшей строки $(|S_1| \leqslant |S_2|)$.
        \item Рассчитать статистику совпадений для $S_2$.
        \item Максиаальное значение $ms(i)$ будет соответствовать длине наибольшей общей подстроки,
              при этом $i$~--- вхождение в $S_2$, а $p(i)$~--- вхождение в $S_1$.
        \item Отличается от предыдущего способа меньшими требованиями к оперативной памяти 
              (меньше размер суффиксного дерева).
     \end{enumerate}
}

\end{document}
    
